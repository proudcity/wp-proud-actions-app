/* global angular */
angular.module("afkl.lazyImage",[]),/* global angular */
angular.module("afkl.lazyImage").service("afklSrcSetService",["$window",function($window){"use strict";
// SRCSET IMG OBJECT
function ImageInfo(options){this.src=options.src,this.w=options.w||1/0,this.h=options.h||1/0,this.x=options.x||1}/**
         * For other applications wanting the srccset/best image approach it is possible to use this module only
         * Loosely based on https://raw.github.com/borismus/srcset-polyfill/master/js/srcset-info.js
         */
var INT_REGEXP=/^[0-9]+$/,_parseDescriptors=function(descString){for(var descriptors=descString.split(/\s/),out={},i=0,l=descriptors.length;l>i;i++){var desc=descriptors[i];if(desc.length>0){var lastChar=desc.slice(-1),value=desc.substring(0,desc.length-1),intVal=parseInt(value,10),floatVal=parseFloat(value);value.match(INT_REGEXP)&&"w"===lastChar?out[lastChar]=intVal:value.match(INT_REGEXP)&&"h"===lastChar?out[lastChar]=intVal:isNaN(floatVal)||"x"!==lastChar||(out[lastChar]=floatVal)}}return out},_getBestCandidateIf=function(images,criteriaFn){for(var bestCandidate=images[0],i=0,l=images.length;l>i;i++){var candidate=images[i];criteriaFn(candidate,bestCandidate)&&(bestCandidate=candidate)}return bestCandidate},_removeCandidatesIf=function(images,criteriaFn){for(var i=images.length-1;i>=0;i--){var candidate=images[i];criteriaFn(candidate)&&images.splice(i,1)}return images},getBestImage=function(imageCandidates,view){if(imageCandidates){view||(view={w:$window.innerWidth||document.documentElement.clientWidth,h:$window.innerHeight||document.documentElement.clientHeight,x:$window.devicePixelRatio||1});var images=imageCandidates.slice(0),largestWidth=_getBestCandidateIf(images,function(a,b){return a.w>b.w});
// Less than client width.
_removeCandidatesIf(images,function(){return function(a){return a.w<view.w}}(this)),
// If none are left, keep the one with largest width.
0===images.length&&(images=[largestWidth]);
// Height
var largestHeight=_getBestCandidateIf(images,function(a,b){return a.h>b.h});
// Less than client height.
_removeCandidatesIf(images,function(){return function(a){return a.h<view.h}}(this)),
// If none are left, keep one with largest height.
0===images.length&&(images=[largestHeight]);
// Pixel density.
var largestPxDensity=_getBestCandidateIf(images,function(a,b){return a.x>b.x});
// Remove all candidates with pxdensity less than client pxdensity.
_removeCandidatesIf(images,function(){return function(a){return a.x<view.x}}(this)),
// If none are left, keep one with largest pixel density.
0===images.length&&(images=[largestPxDensity]);/* SMALLEST */
// Width
var smallestWidth=_getBestCandidateIf(images,function(a,b){return a.w<b.w});
// Remove all candidates with width greater than it.
_removeCandidatesIf(images,function(a){return a.w>smallestWidth.w});
// Height
var smallestHeight=_getBestCandidateIf(images,function(a,b){return a.h<b.h});
// Remove all candidates with height greater than it.
_removeCandidatesIf(images,function(a){return a.h>smallestHeight.h});
// Pixel density
var smallestPxDensity=_getBestCandidateIf(images,function(a,b){return a.x<b.x});
// Remove all candidates with pixel density less than smallest px density.
return _removeCandidatesIf(images,function(a){return a.x>smallestPxDensity.x}),images[0]}},getSrcset=function(options){var imageCandidates=[],srcValue=options.src,srcsetValue=options.srcset;if(srcsetValue){/* PUSH CANDIDATE [{src: _, x: _, w: _, h:_}, ...] */
var _addCandidate=function(img){for(var j=0,ln=imageCandidates.length;ln>j;j++){var existingCandidate=imageCandidates[j];
// DUPLICATE
if(existingCandidate.x===img.x&&existingCandidate.w===img.w&&existingCandidate.h===img.h)return}imageCandidates.push(img)},_parse=function(){for(var url,descriptors,input=srcsetValue,position=0,rawCandidates=[];""!==input;){for(;" "===input.charAt(0);)input=input.slice(1);position=input.indexOf(" "),-1!==position?(url=input.slice(0,position),input=input.slice(position+1),position=input.indexOf(","),-1===position?(descriptors=input,input=""):(descriptors=input.slice(0,position),input=input.slice(position+1)),rawCandidates.push({url:url,descriptors:descriptors})):(rawCandidates.push({url:input,descriptors:""}),input="")}
// FROM RAW CANDIDATES PUSH IMAGES TO COMPLETE SET
for(var i=0,l=rawCandidates.length;l>i;i++){var candidate=rawCandidates[i],desc=_parseDescriptors(candidate.descriptors);_addCandidate(new ImageInfo({src:candidate.url,x:desc.x,w:desc.w,h:desc.h}))}srcValue&&_addCandidate(new ImageInfo({src:srcValue}))};_parse();
// Return best available image for current view based on our list of candidates
var bestImage=getBestImage(imageCandidates),object={best:bestImage,// IMAGE INFORMATION WHICH FITS BEST WHEN API IS REQUESTED
candidates:imageCandidates};
// pass best match and candidates
// empty collection
return imageCandidates=null,object}};/**
         * PUBLIC API
         */
return{get:getSrcset,// RETURNS BEST IMAGE AND IMAGE CANDIDATES
image:getBestImage}}]),/* global angular */
angular.module("afkl.lazyImage").directive("afklImageContainer",function(){"use strict";return{restrict:"A",
// We have to use controller instead of link here so that it will always run earlier than nested afklLazyImage directives
controller:["$scope","$element",function($scope,$element){$element.data("afklImageContainer",$element)}]}}).directive("afklLazyImage",["$window","$timeout","afklSrcSetService",function($window,$timeout,srcSetService){"use strict";
// Use srcSetService to find out our best available image
var bestImage=function(images){var sourceUrl,image=srcSetService.get({srcset:images});return image&&(sourceUrl=image.best.src),sourceUrl};return{restrict:"A",link:function(scope,element,attrs){
// CONFIGURATION VARS
var $container=element.inheritedData("afklImageContainer");$container||($container=angular.element(attrs.afklLazyImageContainer||$window));var timeout,img,loaded=!1,images=attrs.afklLazyImage,options=attrs.afklLazyImageOptions?angular.fromJson(attrs.afklLazyImageOptions):{},currentImage=null,offset=options.offset?options.offset:50,alt=options.alt?'alt="'+options.alt+'"':'alt=""',LOADING="afkl-lazy-image-loading",_containerScrollTop=function(){
// See if we can use jQuery, then extra check since directives like angular-scroll fuck this up as well
// TODO: check if number is returned
if($container.scrollTop){var scrollTopPosition=$container.scrollTop();if(scrollTopPosition)return scrollTopPosition}var c=$container[0];return void 0!==c.pageYOffset?c.pageYOffset:void 0!==c.scrollTop?c.scrollTop:document.documentElement.scrollTop||0},_containerInnerHeight=function(){if($container.innerHeight)return $container.innerHeight();var c=$container[0];return void 0!==c.innerHeight?c.innerHeight:void 0!==c.clientHeight?c.clientHeight:document.documentElement.clientHeight||0},_elementOffset=function(){if(element.offset)return element.offset().top;var box=element[0].getBoundingClientRect();return box.top+_containerScrollTop()-document.documentElement.clientTop},_elementOffsetContainer=function(){return element.offset?element.offset().top-$container.offset().top:element[0].getBoundingClientRect().top-$container[0].getBoundingClientRect().top},_setImage=function(){options.background?element[0].style.backgroundImage='url("'+currentImage+'")':img[0].src=currentImage},_placeImage=function(){loaded=!0,currentImage=bestImage(images),currentImage&&(options.background||img||(element.addClass(LOADING),img=angular.element("<img "+alt+' class="afkl-lazy-image" src=""/>'),img.one("load",_loaded),element.append(img)),_setImage()),$container.off("scroll",_onViewChange)},_checkIfNewImage=function(){if(loaded){var newImage=bestImage(images);newImage!==currentImage&&(currentImage=newImage,_setImage())}};
// First update our begin offset
_checkIfNewImage();var _loaded=function(){element.removeClass(LOADING)},_onViewChange=function(){
// Config vars
var remaining,shouldLoad,windowBottom,height=_containerInnerHeight(),scroll=_containerScrollTop(),elOffset=$container[0]===$window?_elementOffset():_elementOffsetContainer();windowBottom=$container[0]===$window?height+scroll:height,remaining=elOffset-windowBottom,shouldLoad=offset>=remaining,shouldLoad&&!loaded&&_placeImage()},_onResize=function(){$timeout.cancel(timeout),timeout=$timeout(function(){_checkIfNewImage(),_onViewChange()},300)},_eventsOff=function(){$timeout.cancel(timeout),$container.off("scroll",_onViewChange),angular.element($window).off("resize",_onResize),$container[0]!==$window&&$container.off("resize",_onResize),
// remove image being placed
img&&img.remove(),img=timeout=currentImage=void 0};
// Set events for scrolling and resizing
// events for image change
// Image should be directly placed
// Remove all events when destroy takes place
return $container.on("scroll",_onViewChange),angular.element($window).on("resize",_onResize),$container[0]!==$window&&$container.on("resize",_onResize),attrs.$observe("afklLazyImage",function(){images=attrs.afklLazyImage,loaded&&_placeImage()}),options.nolazy&&_placeImage(),scope.$on("$destroy",function(){return _eventsOff()}),_onViewChange()}}}]);